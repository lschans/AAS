/*
 * Master process module
 *
 * Description:  This module will be included and executed when the master starts
 *-----------------------------------------------------
 * Author: Lars van der Schans
 * Email:  lars@wodanbrothers.com
 *-----------------------------------------------------
 */

var config = {},
    log = {},
    numCPUs = require('os').cpus().length;

// Hash function to create a seed from ip to stick a socket to a worker
function hash(ip, seed) {
    var hash = ip.reduce(function(r, num) {
        r += parseInt(num, 10);
        r %= 2147483648;
        r += (r << 10)
        r %= 2147483648;
        r ^= r >> 6;
        return r;
    }, seed);

    hash += hash << 3;
    hash %= 2147483648;
    hash ^= hash >> 11;
    hash += hash << 15;
    hash %= 2147483648;

    return hash >>> 0;
}

module.exports = function(server, cluster, net) {
    config = server.config;
    log = server.log;

    return {
        execute : function () {
            server.cluster.workers = [];
            server.cluster.isMaster = true;
            server.cluster.isWorker = false;

            // Master code, all this code will be executed once
            if (config.global.verbose === true) console.log(numCPUs + ' CPU\'s detected.');

            console.log(server.helpers.dateCookieString(new Date().getTime()));

            // Fork workers.
            for (var i = 0; i < numCPUs; i++) {
                if (config.global.verbose === true) console.log('Forking worker process.');
                server.cluster.workers[i] = cluster.fork();
                server.cluster.workers[i].workerID = i;

                // Receive messages from this worker and handle them in the master process.
                server.cluster.workers[i].on('message', function(msg) {
                    server.helpers.processMessage(msg);
                });
            }

            // Do the seed stuff to make sockets sticky to a worker proc
            var seed = ~~(Math.random() * 1e9);
            server.net = net.createServer(function(c) {
                // Get int31 hash of ip
                var worker,
                    ipHash = hash((c.remoteAddress || '').split(/\./g), seed);

                // Pass connection to worker
                worker = workers[ipHash % workers.length];
                worker.send('sticky-session:connection', c);
            });

            cluster.on('online', function (worker) {
                // Do stuff when a worker comes online
                server.log.writeLog({message:'online', domain:'worker', pid:worker.process.pid});
                if (config.global.verbose === true) console.log("Worker " + worker.process.pid + " responded and is online");
            });

            cluster.on('exit', function (worker, code, signal) {
                // Do stuff when a worker exits or dies
                // TODO: Log exit code and message
                server.log.writeLog({message:'died', domain:'worker', pid:worker.process.pid});
                if (config.global.verbose === true) console.log('Worker ' + worker.process.pid + ' died');
                // Restart the worker
                server.cluster.workers[worker.workerID] = cluster.fork();
                server.cluster.workers[worker.workerID].workerID = worker.workerID;
                // Receive messages from this worker and handle them in the master process.
                server.cluster.workers[worker.workerID].on('message', function(msg) {
                    server.helpers.processMessage(msg);
                });
            });
        }
    }
}