/*
 * Master process module
 *
 * Description:  This module will be included and executed when the master starts
 *-----------------------------------------------------
 * Author: Lars van der Schans
 * Email:  lars@wodanbrothers.com
 *-----------------------------------------------------
 */

var config = {},
    log = {},
    redis = require('redis'),
    numCPUs = require('os').cpus().length,
    redisClient = redis.createClient();


// Do the redis connect and error stuff
redisClient.on('error', function (err) {
    console.log('Redis Error ' + err);
});

redisClient.on('connect', function(){
    console.log('Redis connected');
});

// Should be nice configurable also split stuff for ssl and non-ssl number of threads
var num_processes = numCPUs;

var rrWorkerCount = 0;

// Very basic aproach to redis load balancing. Should watch load and stuff does the RR now
var worker_index = function(ip, len, callback) {
    redisClient.get(ip, function (err, reply) {
        if(reply) {
            // Expire in 900 seconds ( 15 minutes )
            redisClient.expire(ip, 300);
            var workerID = Number(reply.toString());
            callback(workerID);
        } else {
            // Set a value with an expiration
            redisClient.set(ip, rrWorkerCount++);
            // Expire in 900 seconds ( 15 minutes )
            redisClient.expire(ip, 300);
            if(rrWorkerCount >= len) rrWorkerCount = 0;
            callback(rrWorkerCount);
        }
    });
};


module.exports = function(server, cluster, net) {
    config = server.config;
    log = server.log;

    return {
        execute : function () {
            server.cluster.workers = [];
            server.cluster.isMaster = true;
            server.cluster.isWorker = false;

            // Master code, all this code will be executed once
            if (config.global.verbose === true) console.log(numCPUs + ' CPU\'s detected.');

            if(config.global.verbose == true) console.log(server.helpers.dateCookieString(new Date().getTime()));

            // Fork workers.
            for (var i = 0; i < num_processes; i++) {
                if (config.global.verbose === true) console.log('Forking worker process.');
                server.cluster.workers[i] = cluster.fork();
                server.cluster.workers[i].httpPort = config.global.httpStartPort + i;
                server.cluster.workers[i].httpsPort = config.global.httpsStartPort + i;
                server.cluster.workers[i].workerID = i;

                // Receive messages from this worker and handle them in the master process.
                server.cluster.workers[i].on('message', function(msg) {
                    server.helpers.processMessage(msg);
                });
            }

            var x = 0;

            // Do the net stuff to make sockets sticky to a worker proc
            server.net = net.createServer(function(socket) {
                socket.on('data', function (msg) {
                    var serviceSocket = new net.Socket();
                    worker_index(socket.remoteAddress, num_processes, function(num){
                        serviceSocket.connect(parseInt(config.global.httpStartPort + num), 'localhost', function () {

                            serviceSocket.write(msg);
                        });
                        
                        serviceSocket.on('error', function() {
                            console.log("Socket snafu, my PID:" + process.pid);
                        });

                        serviceSocket.on("data", function (data) {
                            socket.write(data);
                        });
                    });
                });
            }).listen(config.global.httpPort);

            // Do the seed stuff to make sockets sticky to a worker proc
            server.net = net.createServer(function(socket) {
                socket.on('data', function (msg) {
                    var serviceSocket = new net.Socket();
                    worker_index(socket.remoteAddress, num_processes, function(num){
                        serviceSocket.connect(parseInt(config.global.httpsStartPort + num), 'localhost', function () {
                            serviceSocket.write(msg);
                        });

                        serviceSocket.on('error', function() {
                            console.log("Socket snafu, my PID:" + process.pid);
                        });

                        serviceSocket.on("data", function (data) {
                            socket.write(data);
                        });
                    });
                });
            }).listen(config.global.httpsPort);

            cluster.on('online', function (worker) {
                // Do stuff when a worker comes online
                //worker.send('start-server:info', { id: worker.workerID,port: worker.port});
                server.log.writeLog({message:'online', domain:'worker', pid:worker.process.pid})
                if (config.global.verbose === true) console.log("Worker " + worker.process.pid + " responded and is online");
                worker.send('start-server:info||' + JSON.stringify({id:worker.id, httpPort:worker.httpPort, httpsPort:worker.httpsPort }));
            });

            cluster.on('exit', function (worker, code, signal) {
                // Do stuff when a worker exits or dies
                // TODO: Log exit code and message
                server.log.writeLog({message:'died', domain:'worker', pid:worker.process.pid});
                if (config.global.verbose === true) console.log('Worker ' + worker.process.pid + ' died');
                // Restart the worker
                server.cluster.workers[worker.workerID] = cluster.fork();
                server.cluster.workers[worker.workerID].workerID = worker.workerID;
                // Receive messages from this worker and handle them in the master process.
                server.cluster.workers[worker.workerID].on('message', function(msg) {
                    server.helpers.processMessage(msg);
                });
            });
        }
    }
}